#include "screen.h"

#include <Arduino.h>

#include "leds.h"
#include "encoder.h"
#include "phototrans.h"
#include "utils.h"

static const int FRAMES_LEN = 64; // Reduce from MAX_FRAMES to 64

void ScreenBase::enter() {}
void ScreenBase::execute() {}
void ScreenBase::leave() {}

ScreenBase *ScreenBase::current = nullptr;
ScreenBase *ScreenBase::defaultScreen = nullptr;
ButtonState ScreenBase::buttonState;

void DefaultScreen::enter()
{
  lastEncoder = getEncoderValue();
}

void DefaultScreen::execute()
{
  uint16_t enc = getEncoderValue();
  int delta = -int16_t(enc - lastEncoder) / 2;
  if (delta != 0)
  {
    lastEncoder = enc;
    level = max(1, min(11, level + delta));
  }
  int pattern = (1 << level) - 1;
  pattern = (pattern << 2) | (pattern >> 10);
  setLitValue(pattern);
}

void TestScreen::execute()
{
  int v1 = getEncoderValue(); // millis() / 100;
  uint32_t display = getPhase() ? 0x03F : 0xFC0;
  display |= (display << 12);
  setLitValue(0xFFF & (display >> (v1 % 12)));
}

void StaticAnimationScreen::enter()
{
  last_frame_t = millis();
  next_frame = 0;
}

void StaticAnimationScreen::execute()
{
  if (millis() - last_frame_t < FRAME_RATE)
  {
    return;
  }
  if (next_frame >= framesCount())
  {
    next_frame = 0;
  }
  last_frame_t = millis();
  setLitValue(frame(next_frame));
  next_frame++;
}

void AnimationScreen::enter()
{
  last_frame_t = millis();
  next_frame = 0;
}

void AnimationScreen::execute()
{
  if (millis() - last_frame_t < FRAME_RATE)
  {
    return;
  }
  last_frame_t = millis();
  setLitValue(framesData.frames[next_frame]);
  next_frame = (next_frame + 1) % framesData.count;
}

void AnimationScreen::setFrames(uint16_t *frames, int count)
{
  framesData.count = count;
  memcpy(framesData.frames, frames, count * sizeof(frames[0]));
  next_frame = 0;
}

void TransmitScreen::enter()
{
  bitIndex = 0;
  last_t = millis() - BIT_RATE - 1;
}

void TransmitScreen::execute()
{
  if (millis() - last_t < BIT_RATE)
  {
    return;
  }
  int byteIndex = bitIndex >> 4;
  uint8_t byte;
  if (byteIndex < 3) {
    if (byteIndex == 2)
      byte = framesData->count * 2;
    else
      byte = byteIndex == 0 ? 0x55 : 0xD5; 
  } else {
    int frameIndex = (byteIndex - 3) >> 1;
    if (frameIndex >= framesData->count) {
      // end of transmit
      setLitValue(0);
      defaultScreen->select();
      return;
    }
    byte = (byteIndex & 1) ? framesData->frames[frameIndex] : (framesData->frames[frameIndex] >> 8);
  }
  bool f = !(bitIndex & 1);
  int bit = (bitIndex >> 1) & 7;
  bool pos = (((byte >> bit) & 1) != 0) == f;
  setLitValue(pos ? 0b111000 : 0b111000000000);
  bitIndex++;
  last_t = millis();
}
 
/*
Generated by python:
import hashlib

def hash(b):
  
  m = hashlib.sha256()
  m.update(b)
  d = m.digest()
  s = "  {"
  for i in range(0, len(d)):
    s += hex(d[i]) + ", "
  print(s + "},")

hash(bytearray([-1 & 255, 2, -3 & 255]))
hash(bytearray([2, 0, -2 & 255, 5]))
*/
const unsigned char hashes[][32] = {
  {0xbc, 0xb4, 0xb6, 0x52, 0x96, 0x1e, 0x3c, 0xfb, 0x7a, 0x73, 0xe4, 0xcb, 0x93, 0x67, 0x34, 0xb2, 0xcc, 0xb2, 0x73, 0xbf, 0x9, 0xd4, 0x32, 0x46, 0xb3, 0xb1, 0xb0, 0xce, 0xd6, 0xbe, 0xe8, 0xf9, },
  {0x88, 0xa7, 0xac, 0x3c, 0xb7, 0x95, 0x94, 0x85, 0xe8, 0x43, 0xbd, 0xe4, 0x82, 0xe3, 0x88, 0x2f, 0x94, 0x1d, 0xdc, 0xb9, 0xc7, 0x2e, 0xc, 0x34, 0xac, 0xdc, 0x2b, 0x94, 0xf3, 0xac, 0x1, 0x76, },
};

static bool hasHash(const int8_t* steps, int len)
{
  uint8_t out[32];
  sha256(out, reinterpret_cast<const uint8_t*>(steps), len);

  for (int i = 0; i < sizeof(hashes) / 32; i++) {
    if (memcmp(out, hashes[i], 32) == 0) return true;
  }
  return false;
}

void GameScreen::enter()
{
  reset();
}

void GameScreen::execute()
{
  int v = max(-11, min(11, int(int16_t(lastEnc - getEncoderValue()))));
  int pattern = (1 << abs(v))- 1;
  int shift = (v >= 0 ? startLed + 2 : startLed + 13 + v) % 12;
  setLitValue(((pattern >> (12 - shift)) | (pattern << shift)) & 0xFFF);

  if (buttonState.clicked)
  {
    addInput(v);
    startLed += v;
    lastEnc = getEncoderValue();
    if (hasHash(steps, stepIndex)) {
      setLitValue(0xfff);
      delay(300);
      setLitValue(0);
      // TODO something else? e.g. dance, reset
    }
  }
}

void GameScreen::addInput(int step)
{
  if (stepIndex < MAX_STEPS) {
    steps[stepIndex++] = step;
  }
}

bool GameScreen::isDone() const
{
  return false;
}

void GameScreen::reset() {
  stepIndex = 0;
  startLed = 0;
  lastEnc = getEncoderValue();
}

int BreathingScreen::framesCount() const
{
  return 22 * 4;
}

uint16_t BreathingScreen::frame(int i) const
{
  i >>= 2;
  int len = (i < 11) ? i : (22 - i);
  return ((1 << len) - 1) << 2;
}
