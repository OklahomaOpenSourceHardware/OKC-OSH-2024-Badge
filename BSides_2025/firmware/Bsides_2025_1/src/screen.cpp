#include "screen.h"

#include <Arduino.h>

#include "leds.h"
#include "encoder.h"
#include "phototrans.h"
#include "utils.h"

static const int FRAMES_LEN = 64; // Reduce from MAX_FRAMES to 64

void ScreenBase::enter() {}
void ScreenBase::execute() {}
void ScreenBase::leave() {}

ScreenBase *ScreenBase::current = nullptr;
ScreenBase *ScreenBase::defaultScreen = nullptr;
ButtonState ScreenBase::buttonState;

void DefaultScreen::enter()
{
  lastEncoder = getEncoderValue();
}

void DefaultScreen::execute()
{
  uint16_t enc = getEncoderValue();
  int delta = -int16_t(enc - lastEncoder) / 2;
  if (delta != 0)
  {
    lastEncoder = enc;
    level = max(1, min(11, level + delta));
  }
  int pattern = (1 << level) - 1;
  pattern = (pattern << 2) | (pattern >> 10);
  setLitValue(pattern);
}

void TestScreen::execute()
{
  int v1 = getEncoderValue(); // millis() / 100;
  uint32_t display = getPhase() ? 0x03F : 0xFC0;
  display |= (display << 12);
  setLitValue(0xFFF & (display >> (v1 % 12)));
}

void StaticAnimationScreen::enter()
{
  last_frame_t = millis();
  next_frame = 0;
}

void StaticAnimationScreen::execute()
{
  if (millis() - last_frame_t < FRAME_RATE)
  {
    return;
  }
  if (next_frame >= framesCount())
  {
    next_frame = 0;
  }
  last_frame_t = millis();
  setLitValue(frame(next_frame));
  next_frame++;
}

void AnimationScreen::enter()
{
  last_frame_t = millis();
  next_frame = 0;
}

void AnimationScreen::execute()
{
  if (millis() - last_frame_t < FRAME_RATE)
  {
    return;
  }
  last_frame_t = millis();
  setLitValue(framesData.frames[next_frame]);
  next_frame = (next_frame + 1) % framesData.count;
}

void AnimationScreen::setFrames(uint16_t *frames, int count)
{
  framesData.count = count;
  memcpy(framesData.frames, frames, count * sizeof(frames[0]));
  next_frame = 0;
}

void TransmitScreen::enter()
{
  bitIndex = 0;
  last_t = millis() - BIT_RATE - 1;
}

void TransmitScreen::execute()
{
  if (millis() - last_t < BIT_RATE)
  {
    return;
  }
  int byteIndex = bitIndex >> 4;
  uint8_t byte;
  if (byteIndex < 3) {
    if (byteIndex == 2)
      byte = framesData->count * 2;
    else
      byte = byteIndex == 0 ? 0x55 : 0xD5; 
  } else {
    int frameIndex = (byteIndex - 3) >> 1;
    if (frameIndex >= framesData->count) {
      // end of transmit
      setLitValue(0);
      defaultScreen->select();
      return;
    }
    byte = (byteIndex & 1) ? framesData->frames[frameIndex] : (framesData->frames[frameIndex] >> 8);
  }
  bool f = !(bitIndex & 1);
  int bit = (bitIndex >> 1) & 7;
  bool pos = (((byte >> bit) & 1) != 0) == f;
  setLitValue(pos ? 0b111000 : 0b111000000000);
  bitIndex++;
  last_t = millis();
}
 
/*
Generated by python:
import hashlib

def hash(b):
  
  m = hashlib.sha256()
  m.update(b)
  d = m.digest()
  s = "  {"
  for i in range(0, len(d)):
    s += hex(d[i]) + ", "
  print(s + "},")

hash(bytearray([-1 & 255, 2, -3 & 255]))
hash(bytearray([2, 0, -2 & 255, 5]))
*/
const unsigned char hashes[][32] = {
  {0x6e, 0x34, 0xb, 0x9c, 0xff, 0xb3, 0x7a, 0x98, 0x9c, 0xa5, 0x44, 0xe6, 0xbb, 0x78, 0xa, 0x2c, 0x78, 0x90, 0x1d, 0x3f, 0xb3, 0x37, 0x38, 0x76, 0x85, 0x11, 0xa3, 0x6, 0x17, 0xaf, 0xa0, 0x1d, },
  {0x46, 0x53, 0xff, 0xe, 0x23, 0xcc, 0xd1, 0x68, 0x4, 0x31, 0xc3, 0x4c, 0xc2, 0x46, 0x61, 0x2f, 0xf, 0x90, 0x8e, 0xb4, 0x79, 0xae, 0xa3, 0xf7, 0xe5, 0xd2, 0xe0, 0x14, 0x27, 0x83, 0x71, 0x8a, },
  {0x96, 0x73, 0xe, 0x8c, 0xc7, 0xf4, 0x20, 0x57, 0xc8, 0xe7, 0xc3, 0x4e, 0x78, 0x14, 0x36, 0x95, 0x89, 0x2e, 0xd7, 0xc2, 0x46, 0x7d, 0xbf, 0x40, 0xe9, 0x38, 0x35, 0xe2, 0x14, 0x26, 0x43, 0x58, },
  {0xac, 0xec, 0x31, 0x51, 0xda, 0xb8, 0x77, 0xd5, 0x91, 0xb9, 0xee, 0xd5, 0x69, 0x64, 0xcd, 0x46, 0xc2, 0x64, 0xb6, 0x47, 0x21, 0x7, 0x39, 0x8f, 0x3c, 0xaf, 0xb0, 0x7e, 0x1d, 0x9f, 0xbd, 0xc, },
  {0x84, 0xdf, 0xfe, 0x79, 0x5a, 0xed, 0x85, 0x40, 0xae, 0x80, 0x42, 0x79, 0x9f, 0x28, 0x9b, 0xd, 0xac, 0x5d, 0xd7, 0x87, 0xf, 0xdb, 0xff, 0x6c, 0xca, 0x1e, 0x3c, 0x8b, 0x2c, 0x2c, 0x9b, 0x77, },
  {0x21, 0x3e, 0x99, 0xc9, 0xf4, 0x4c, 0x53, 0x60, 0xdc, 0x9f, 0x2b, 0xb4, 0xf0, 0xd4, 0xd, 0xab, 0x72, 0x87, 0x34, 0xb8, 0x40, 0x84, 0x98, 0x6f, 0x76, 0x36, 0x0, 0xaa, 0x8b, 0xbf, 0x70, 0xdf, },
  {0x10, 0x9e, 0x5a, 0xe, 0xdf, 0x28, 0xf7, 0xd5, 0x9e, 0xee, 0xac, 0x9b, 0x4b, 0xba, 0x51, 0x6e, 0x8, 0xcc, 0x41, 0xb8, 0x2f, 0x16, 0xff, 0xec, 0x83, 0x9f, 0x8c, 0x25, 0x7f, 0x0, 0x10, 0x6f, },
  {0x57, 0x25, 0xf0, 0x9e, 0x45, 0xcf, 0x3e, 0x7a, 0xca, 0x73, 0x1d, 0x57, 0xf2, 0x99, 0x23, 0x22, 0x83, 0x30, 0x4, 0xa4, 0x53, 0x15, 0xce, 0x76, 0xaf, 0x7, 0x9d, 0x4c, 0xd4, 0x46, 0x1d, 0xd5, },
  {0x96, 0xfe, 0x7f, 0xb0, 0xfe, 0xe1, 0xb3, 0x6c, 0x41, 0x76, 0x20, 0xb, 0xa9, 0xbc, 0x69, 0xfc, 0x37, 0x57, 0xdf, 0xa9, 0x6b, 0xcc, 0xc5, 0x20, 0x6b, 0x7, 0xe, 0x90, 0xea, 0x71, 0x4e, 0x84, },
  {0xd4, 0xa4, 0x60, 0x48, 0xd3, 0xc, 0x13, 0x99, 0x88, 0x92, 0x8a, 0xbb, 0xfc, 0x7b, 0x5b, 0x6a, 0x9a, 0xc0, 0xf3, 0xd0, 0x66, 0x85, 0x2e, 0xd4, 0x7a, 0xe8, 0x29, 0x5d, 0xb0, 0xca, 0xc, 0x74, },
  {0x7e, 0x35, 0x55, 0xd1, 0x6e, 0x66, 0xa, 0x45, 0xeb, 0x39, 0x5c, 0xe5, 0xf4, 0x48, 0x81, 0x5b, 0x72, 0xa3, 0xf6, 0x18, 0xc7, 0x29, 0x30, 0x4b, 0x80, 0x5f, 0x81, 0xa2, 0x9d, 0xab, 0x5e, 0xac, }
  };

static int hasHash(const int8_t* steps, int len)
{
  uint8_t out[32];
  sha256(out, reinterpret_cast<const uint8_t*>(steps), len);

  for (int i = 0; i < sizeof(hashes) / 32; i++) {
    if (memcmp(out, hashes[i], 32) == 0) return i;
  }
  return -1;
}

void GameScreen::enter()
{
  reset();
  if(completedHashFlag == 0b111111111111) {
    setLitValue(0xFFF);
    delay(300);
    setLitValue(0);
    delay(300);
    setLitValue(0xFFF);
    delay(300);
    setLitValue(0);
    delay(300);
  }
  
}

void GameScreen::execute()
{
  int v = max(-11, min(11, int(int16_t(lastEnc - getEncoderValue()))));
  int pattern = (1 << abs(v))- 1;
  int shift = (v >= 0 ? startLed + 2 : startLed + 13 + v) % 12;
  setLitValue(((pattern >> (12 - shift)) | (pattern << shift)) & 0xFFF);

  if (buttonState.clicked)
  {
    addInput(v);
    startLed += v;
    lastEnc = getEncoderValue();
    int q = hasHash(steps, stepIndex);
    if(q >= 0) {
      completedHashFlag |= (1 << q);
      if (completedHashFlag == 0b111111111111) {
        setLitValue(0xFFF);
        delay(300);
        setLitValue(0);
        delay(300);
        setLitValue(0xFFF);
        delay(300);
        setLitValue(0);
        delay(300);
      }
      setLitValue(0xfff);
      delay(300);
      setLitValue(0);
      reset();
    }
  }
}

void GameScreen::addInput(int step)
{
  if (stepIndex < MAX_STEPS) {
    steps[stepIndex++] = step;
  }
}

bool GameScreen::isDone() const
{
  return false;
}

void GameScreen::reset() {
  stepIndex = 0;
  startLed = 0;
  lastEnc = getEncoderValue();
  setLitValue(completedHashFlag);
  delay(300);
  setLitValue(0);
}

int BreathingScreen::framesCount() const
{
  return 22 * 4;
}

uint16_t BreathingScreen::frame(int i) const
{
  i >>= 2;
  int len = (i < 11) ? i : (22 - i);
  return ((1 << len) - 1) << 2;
}
